# 実運用統合シナリオテスト仕様書

## 概要
本仕様書は、有給休暇システムの実運用で発生する一連の現象を再現し、システム全体が期待通りに動作することを検証するテストケースを定義する。
日次処理、シグナル処理、各種サービスクラスが連携して正常に機能することを確認する。

## テストシナリオ一覧

### シナリオ1: 新入社員の入社から初回有給付与まで

#### シナリオ1-1: 通常労働者の標準的な初回付与プロセス
**背景**: 2023年1月1日に入社した通常労働者（週5日勤務）の6か月後の初回有給付与

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
  - 氏名: "田中太郎"
- **出勤記録（2023年1月1日〜6月30日）**:
  - 総出勤日数: 110日
  - 判定対象期間: 181日間
  - 所定労働日数: 129日（181÷7×5=129.28→129）
  - 出勤率: 85.3%（110÷129=0.853）
- **日次処理実行日**: 2023年7月1日

**実行手順**:
1. ユーザー作成とpaid_leave_grant_schedule自動計算
2. 期間中の出勤記録を作成（TimeRecord 110件作成）
   - 各TimeRecord属性:
     - timestamp: 各出勤日の09:00（clock_in）
     - clock_out_time: 各出勤日の18:00（clock_out）
     - clock_type: 'clock_in' / 'clock_out'のペア
     - user: 対象ユーザー
3. 2023年7月1日に日次処理実行（management command）
4. 結果確認

**検証値と期待結果**:
- **paid_leave_grant_schedule**: [2023年7月1日, 2024年7月1日, ...]
- **付与判定結果**:
  - is_eligible: True
  - grant_days: 10日
  - attendance_rate: 0.853
  - period_start: 2023年1月1日
  - period_end: 2023年6月30日
- **PaidLeaveRecord作成**:
  - record_type: 'grant'
  - days: 10
  - grant_date: 2023年7月1日
  - expiry_date: 2025年7月1日
- **残日数更新**: user.current_paid_leave = 10日
- **ログ出力**: "付与成功: user=X, days=10"

#### シナリオ1-2: 出勤率不足による初回付与失敗
**背景**: 出勤率が80%未満のため初回付与が失敗するケース

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
- **出勤記録**:
  - 総出勤日数: 100日
  - 所定労働日数: 129日
  - 出勤率: 77.5%（100÷129=0.775）
- **日次処理実行日**: 2023年7月1日

**検証値と期待結果**:
- **付与判定結果**:
  - is_eligible: False
  - grant_days: 0日
  - attendance_rate: 0.775
- **PaidLeaveRecord作成**: なし
- **残日数更新**: user.current_paid_leave = 0日（変更なし）

### シナリオ2: 継続的な有給付与と使用のライフサイクル

#### シナリオ2-1: 2年間の継続勤務による2回目付与
**背景**: 初回付与から1年後の2回目付与プロセス

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
  - current_paid_leave: 7日
- **既存PaidLeaveRecord**:
  - 付与記録: grant_date=2023年7月1日, days=10, record_type='grant'
  - 使用記録: used_date=2023年8月15日, days=3, record_type='use', grant_date=2023年7月1日
- **出勤記録（2023年7月1日〜2024年6月30日）**:
  - 総出勤日数: 220日
  - 有給使用日数: 3日
  - 実質出勤日数: 223日
  - 所定労働日数: 261日（366÷7×5=261.4→261）
  - 出勤率: 85.4%（223÷261=0.854）
- **日次処理実行日**: 2024年7月1日

**実行手順**:
1. 2023年7月1日〜2024年6月30日の期間の出勤記録作成
2. 有給使用記録3件作成（TimeRecord + PaidLeaveRecord）
3. 2024年7月1日に日次処理実行
4. 結果確認

**検証値と期待結果**:
- **付与判定結果**:
  - is_eligible: True
  - grant_days: 11日（2回目付与）
  - judgment_date: 2024年7月1日
  - attendance_rate: 0.854
- **PaidLeaveRecord作成**:
  - record_type: 'grant'
  - days: 11
  - grant_date: 2024年7月1日
  - expiry_date: 2026年7月1日
- **残日数更新**: user.current_paid_leave = 18日（7+11）

#### シナリオ2-2: 有給使用とシグナル連携
**背景**: 有給使用申請時のシグナル処理による残日数自動更新

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - current_paid_leave: 18日
- **既存PaidLeaveRecord**:
  - 1回目付与: grant_date=2023年7月1日, days=10, record_type='grant'
  - 2回目付与: grant_date=2024年7月1日, days=11, record_type='grant'
  - 使用記録: 既存使用なし（全残存）
- **有給使用申請**:
  - 使用日: 2024年8月1日
  - 使用日数: 2日

**実行手順**:
1. PaidLeaveRecord作成（record_type='use', days=2）
2. シグナル自動発火確認
3. 残日数更新確認

**検証値と期待結果**:
- **PaidLeaveRecordシグナル発火**: ✅ handle_paid_leave_record_change実行
- **残日数更新**: user.current_paid_leave = 16日（18-2）
- **使用記録作成**:
  - record_type: 'use'
  - days: 2
  - used_date: 2024年8月1日
  - grant_date: 初回付与日から古い順に消費

### シナリオ3: 時効消滅とその処理

#### シナリオ3-1: 2年後の時効消滅処理
**背景**: 2023年7月1日付与の有給が2025年7月1日に時効消滅

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - current_paid_leave: 16日
- **既存PaidLeaveRecord**:
  - 1回目付与: grant_date=2023年7月1日, days=10, record_type='grant', expiry_date=2025年7月1日
  - 1回目使用: used_date=2023年9月1日, days=5, record_type='use', grant_date=2023年7月1日
  - 2回目付与: grant_date=2024年7月1日, days=11, record_type='grant', expiry_date=2026年7月1日
  - 計算: (10-5) + 11 = 16日
- **時効処理実行日**: 2025年7月1日

**実行手順**:
1. 2025年7月1日に日次処理実行
2. 時効処理自動実行確認
3. 新規付与と時効消滅の同時処理確認

**検証値と期待結果**:
- **時効消滅記録作成**:
  - record_type: 'expire'
  - days: 5日（2023年7月1日付与分の未使用分）
  - grant_date: 2023年7月1日
  - expiry_date: 2025年7月1日
- **新規付与記録作成**:
  - record_type: 'grant'
  - days: 12日（3回目付与）
  - grant_date: 2025年7月1日
  - expiry_date: 2027年7月1日
- **残日数更新**: user.current_paid_leave = 23日（16-5+12）

### シナリオ4: 打刻修正による再判定プロセス

#### シナリオ4-1: 打刻追加による付与条件充足と再判定
**背景**: 付与失敗後に打刻記録を追加し、出勤率改善により付与条件を満たすケース

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
- **初期状態（2023年7月1日時点）**:
  - 出勤日数: 100日
  - 所定労働日数: 129日
  - 出勤率: 77.5%（付与失敗）
  - current_paid_leave: 0日
- **打刻修正（2023年7月15日実行）**:
  - 追加日付: 2023年6月25日、26日、27日、28日（4日分追加）
  - 各日のTimeRecord:
    - timestamp: 09:00 (clock_in), 18:00 (clock_out)
    - clock_type: 'clock_in', 'clock_out'
    - 計6件のTimeRecord作成（4日×2件ずつ）

**実行手順**:
1. 2023年7月1日に日次処理実行（付与失敗確認）
2. 2023年7月15日にTimeRecord 4件追加作成
3. TimeRecordシグナル自動発火確認
4. 再判定処理実行確認
5. 結果確認

**検証値と期待結果**:
- **TimeRecordシグナル発火**: ✅ 3件の追加でそれぞれシグナル発火
- **再判定実行**: ✅ should_rejudge=Trueで1回目付与再判定
- **修正後の付与判定結果**:
  - is_eligible: True
  - grant_days: 10日
  - attendance_rate: 0.806（103÷129=0.806、80%以上）
- **PaidLeaveRecord作成**:
  - record_type: 'grant'
  - days: 10
  - grant_date: 2023年7月1日
  - description: "再判定により"
- **残日数更新**: user.current_paid_leave = 10日

#### シナリオ4-2: 打刻削除による付与取消と部分取消処理
**背景**: 既に付与・使用済みの有給が打刻削除により取消になるケース

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
- **既存PaidLeaveRecord**:
  - 付与記録: grant_date=2023年7月1日, days=10, record_type='grant', expiry_date=2025年7月1日
  - 使用記録: used_date=2023年8月1日, days=3, record_type='use', grant_date=2023年7月1日
- **ユーザー状態**:
  - 入社日: 2023年1月1日  
  - current_paid_leave: 7日
- **打刻削除（2023年8月15日実行）**:
  - 削除対象: 2023年6月20日〜25日の6日分（出勤率低下）
  - 削除TimeRecord詳細:
    - 各日のclock_in/clock_outペア（計12件削除）
    - timestamp: 09:00〜18:00の打刻記録
    - 削除により出勤日数が6日減少

**実行手順**:
1. 初期状態確認（付与10日、使用3日、残7日）
2. 2023年8月15日にTimeRecord 6件削除
3. TimeRecordシグナル自動発火確認
4. 再判定による部分取消処理確認

**検証値と期待結果**:
- **TimeRecordシグナル発火**: ✅ 6件の削除でそれぞれシグナル発火
- **再判定実行**: ✅ 1回目付与の再判定実行
- **修正後の付与判定結果**:
  - is_eligible: False
  - grant_days: 0日
  - attendance_rate: 76.7%（80%未満）
- **部分取消処理**:
  - target_cancel_days: 10日（全額取消希望）
  - actual_cancelled_days: 7日（残日数の範囲内）
  - remaining_balance: 0日
- **PaidLeaveRecord作成**:
  - record_type: 'cancel'
  - days: 7日
  - description: "再判定により"
- **残日数更新**: user.current_paid_leave = 0日

### シナリオ5: パートタイム労働者の比例付与

#### シナリオ5-1: 週3日勤務パートタイマーの付与プロセス
**背景**: 週3日勤務のパートタイマーの比例付与

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 3日
- **出勤記録（2023年1月1日〜6月30日）**:
  - 総出勤日数: 70日
  - 所定労働日数: 77日（181÷7×3=77.57→77）
  - 出勤率: 90.9%（70÷77=0.909）
- **日次処理実行日**: 2023年7月1日

**検証値と期待結果**:
- **付与判定結果**:
  - is_eligible: True
  - grant_days: 5日（週3日勤務の1回目付与）
  - attendance_rate: 0.909
- **PaidLeaveRecord作成**:
  - record_type: 'grant'
  - days: 5
  - grant_date: 2023年7月1日
  - expiry_date: 2025年7月1日
- **残日数更新**: user.current_paid_leave = 5日

### シナリオ6: 大量ユーザーでの日次処理

#### シナリオ6-1: 同一付与日の大量ユーザー一括処理
**背景**: 同じ日に多数のユーザーの付与処理が発生するケース

**設定値**:
- **ユーザー数**: 100名
- **ユーザー構成**:
  - 通常労働者（週5日）: 70名
  - パートタイマー（週3日）: 20名
  - パートタイマー（週2日）: 10名
- **共通設定**:
  - 入社日: 2023年1月1日
  - 付与日: 2023年7月1日
  - 全ユーザー出勤率: 85%以上（付与条件満たす）

**実行手順**:
1. 100名のユーザー作成
2. 各ユーザーの出勤記録作成
3. 2023年7月1日に日次処理実行
4. 処理時間・結果確認

**検証値と期待結果**:
- **処理完了時間**: 60秒以内
- **付与判定結果**: 100件すべてが成功
- **付与日数内訳**:
  - 週5日勤務者: 10日×70名 = 700日
  - 週3日勤務者: 5日×20名 = 100日
  - 週2日勤務者: 3日×10名 = 30日
- **総付与日数**: 830日
- **PaidLeaveRecord作成**: 100件
- **全ユーザー残日数更新**: 正常完了
- **ログ出力**: "処理対象=100名, 付与成功=100名"

### シナリオ7: 複雑な月末日付の処理

#### シナリオ7-1: 2月29日入社者の付与日計算
**背景**: うるう年の2月29日入社者の付与日計算と存在しない日付の処理

**設定値**:
- **ユーザー設定**:
  - 入社日: 2020年2月29日（うるう年）
  - 週所定労働日数: 5日
- **付与日期待値**:
  - 1回目: 2020年8月29日
  - 2回目: 2021年8月29日
  - 3回目: 2022年8月29日
  - 4回目: 2023年8月29日
  - 5回目: 2024年8月29日

**実行手順**:
1. ユーザー作成とpaid_leave_grant_schedule確認
2. 各付与日での日次処理実行
3. 日付計算の正確性確認

**検証値と期待結果**:
- **paid_leave_grant_schedule**: [2020年8月29日, 2021年8月29日, 2022年8月29日, 2023年8月29日, 2024年8月29日, 2025年8月29日, ...]
- **5回目付与日**: 2024年8月29日（入社から4年6か月後）
- **各付与処理**: すべて正常実行
- **expiry_date計算**: 各付与日から正確に2年後

#### シナリオ7-2: 月末日入社者での存在しない日付処理
**背景**: 存在しない日付での月末調整の正確な処理

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年8月31日
  - 週所定労働日数: 5日
- **付与日期待値**:
  - 1回目: 2024年2月29日（2024年2月31日→2月29日に調整）
  - 2回目: 2025年2月28日（2025年2月31日→2月28日に調整、平年）
  - 3回目: 2026年2月28日（2026年2月31日→2月28日に調整）

**検証値と期待結果**:
- **月末調整**: 存在しない日付は正しく月末に調整される
- **平年・うるう年**: 年によって正しく2月28日/29日を使い分ける
- **expiry_date**: 付与日から2年後の正確な計算（同様の月末調整あり）

### シナリオ8: エラー回復と整合性保証

#### シナリオ8-1: データベース接続エラーからの回復
**背景**: 日次処理中のデータベース接続エラーとその回復

**設定値**:
- **処理対象ユーザー**: 50名（付与対象）
- **エラー発生タイミング**: 25名処理完了後
- **エラー内容**: データベース接続タイムアウト

**実行手順**:
1. 日次処理開始
2. 25名処理完了時点でDB接続エラーを模擬発生
3. エラー処理とロールバック確認
4. 処理再開と残り25名の処理完了確認

**検証値と期待結果**:
- **エラー処理**: ✅ 適切な例外ハンドリング
- **データ整合性**: ✅ 処理済み25名のデータは保持
- **ログ出力**: ✅ エラー詳細とスタックトレース記録
- **処理再開**: ✅ 残り25名の処理が正常完了
- **最終状態**: 全50名の付与処理完了

#### シナリオ8-2: シグナル処理での例外とシステム継続性
**背景**: シグナル処理中の例外がシステム全体に影響しないことの確認

**設定値**:
- **処理内容**: TimeRecord一括作成（100件）
- **例外発生**: 50件目でPaidLeaveAutoProcessorエラー

**実行手順**:
1. TimeRecord 100件を一括作成
2. 50件目でシグナル処理エラーを模擬発生
3. 残り50件の処理継続確認
4. システム全体の安定性確認

**検証値と期待結果**:
- **エラー処理**: ✅ 個別シグナルエラーでシステム停止しない
- **処理継続**: ✅ 残り50件のシグナル処理正常実行
- **データ整合性**: ✅ エラー件以外は正常処理
- **ログ出力**: ✅ エラー件数と詳細を記録

## テスト実行環境要件

### データベース設定
- PostgreSQL使用（本番環境と同等）
- トランザクション分離レベル: READ COMMITTED
- 接続プール設定: 最大20接続

### テストデータ準備
- **ユーザーマスター**: 事前準備済み
- **TimeRecord**: 各シナリオで動的生成
  - 必須属性: timestamp, clock_type, user
  - clock_type: 'clock_in', 'clock_out', 'break_start', 'break_end'
  - 出勤日の認識: clock_in/clock_outのペアで1日として計算
  - 有給使用日: TimeRecordには記録せず、PaidLeaveRecordのみで管理

#### TimeRecord作成の詳細手順
```python
# 出勤日の作成（clock_in/clock_outペア）
def create_work_day(user, date):
    # clock_in記録
    TimeRecord.objects.create(
        user=user,
        timestamp=datetime.combine(date, time(9, 0)),
        clock_type='clock_in'
    )
    # clock_out記録  
    TimeRecord.objects.create(
        user=user,
        timestamp=datetime.combine(date, time(18, 0)),
        clock_type='clock_out'
    )

# 有給使用日の作成
def create_paid_leave_day(user, date, grant_date):
    # 有給使用はPaidLeaveRecordのみで管理（TimeRecordには記録しない）
    PaidLeaveRecord.objects.create(
        user=user,
        record_type='use',
        days=1,
        used_date=date,
        grant_date=grant_date
    )
```

- **PaidLeaveRecord**: 初期状態から段階的に作成
  - record_type: 'grant', 'use', 'cancel', 'expire'
  - 使用記録はTimeRecordと連動して作成

#### 日次処理コマンド実行方法
```python
# management commandの実行
from django.core.management import call_command
from io import StringIO

def run_daily_process(target_date):
    out = StringIO()
    call_command('process_daily_paid_leave', 
                 date=target_date.strftime('%Y-%m-%d'),
                 stdout=out)
    return out.getvalue()
```

### 性能要件
- 100名同時処理: 60秒以内
- 1000件TimeRecord作成: 30秒以内
- シグナル処理レスポンス: 1件あたり100ms以内

### 監視・検証項目
- CPU使用率: 80%以下を維持
- メモリ使用量: 1GB以下を維持
- データベース接続数: 設定上限の50%以下
- ログ出力: 全処理の開始・終了・エラーを記録

### シナリオ9: 境界値・エッジケーステスト

#### シナリオ9-1: 出勤率ちょうど80.0%での付与判定
**背景**: 付与条件ギリギリでの正確な判定

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
- **出勤記録（判定期間: 181日）**:
  - 所定労働日数: 129日（181÷7×5=129.28→129）
  - 出勤日数: 103日（103÷129=0.798...）
  - 有給使用日数: 1日
  - 実質出勤日数: 104日（103+1）
  - 出勤率: 80.620%（104÷129=0.806）

**検証値と期待結果**:
- **付与判定**: is_eligible=True（80%以上）
- **付与日数**: 10日
- **境界値確認**: 80.0%ちょうどでも付与される

#### シナリオ9-2: 出勤率79.9%での付与失敗
**背景**: 付与条件を僅かに下回る場合の処理

**設定値**:
- **出勤日数**: 103日（79.845%）
- **有給使用**: なし
- **出勤率**: 79.845%（80%未満）

**検証値と期待結果**:
- **付与判定**: is_eligible=False
- **付与日数**: 0日
- **境界値確認**: 80%未満では付与されない

#### シナリオ9-3: 所定労働日数が0日の期間での処理
**背景**: 極短期間での異常ケース処理

**設定値**:
- **判定期間**: 6日間（土日のみ）
- **所定労働日数**: 0日（6÷7×5=4.28→4、週5日中土日のみ）
- **出勤日数**: 0日

**検証値と期待結果**:
- **エラー処理**: 適切な例外またはスキップ処理
- **システム継続**: 他の処理に影響しない

#### シナリオ9-4: 付与日数上限（20日）の正確な適用
**背景**: 7回目以降の付与上限テスト

**設定値**:
- **ユーザー設定**:
  - 入社日: 2017年1月1日（7年以上前）
  - 週所定労働日数: 5日
- **付与回数**: 8回目（勤続7年6か月）
- **出勤率**: 85%（十分）

**検証値と期待結果**:
- **付与判定**: is_eligible=True
- **付与日数**: 20日（上限適用）
- **継続確認**: 9回目以降も20日で継続

### シナリオ10: 同時実行・競合状態テスト

#### シナリオ10-1: 同一ユーザーのTimeRecord同時作成処理
**背景**: 同じユーザーの複数TimeRecordが同時に作成される際の処理

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
  - 既存付与: なし（初回付与前）
- **同時作成するTimeRecord**:
  - Thread1: 2023年6月29日の出勤記録
  - Thread2: 2023年6月30日の出勤記録
  - 両方とも付与条件に影響する重要な日付

**検証値と期待結果**:
- **競合回避**: デッドロックが発生しない
- **データ整合性**: 両方のTimeRecordが正常に保存される
- **シグナル処理**: 両方のシグナルが適切に実行される
- **最終状態**: 出勤日数が正しく2日増加している

#### シナリオ10-2: シグナル処理中の別シグナル発火
**背景**: TimeRecordシグナル処理中に別のPaidLeaveRecordシグナルが発火

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 週所定労働日数: 5日
  - current_paid_leave: 10日
- **同時処理**:
  - Process1: TimeRecord作成（再判定処理開始）
  - Process2: PaidLeaveRecord使用記録作成（残日数更新処理）

**検証値と期待結果**:
- **処理順序**: シグナル処理が適切な順序で実行される
- **データ一貫性**: 最終的な残日数計算が正確
- **ロック制御**: データベースレベルでの排他制御が機能

#### シナリオ10-3: 日次処理中のTimeRecord修正
**背景**: 日次付与処理実行中に該当ユーザーのTimeRecordが修正される

**設定値**:
- **ユーザー設定**:
  - 入社日: 2023年1月1日
  - 付与日: 2023年7月1日
- **同時処理**:
  - Process1: 日次付与処理実行中
  - Process2: 2023年6月30日のTimeRecord削除

**検証値と期待結果**:
- **処理競合**: どちらかの処理が適切に待機または再実行
- **最終状態**: より後に実行された処理の結果が反映
- **データ整合性**: 矛盾のない最終状態

## 実行結果の検証方法

### 自動検証項目
- 付与判定結果の数値的正確性
- データベース整合性制約の確認
- 残日数計算の数式的正確性
- ログ出力内容の完全性

### 手動検証項目
- ユーザーインターフェース表示の確認
- 帳票出力結果の妥当性確認
- 例外ケースでのシステム挙動確認

この統合テスト仕様書により、有給休暇システムが実運用環境で確実に動作することを保証します。